/*
 * Copyright (c)2000-2001 Bo Blanton::UC Berkeley Dept of Chemistry
 * author:: Bo Blanton
 * contact:: magneto@dirac.cchem.berkeley.edu
 * last modified:: 06-25-01
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/*Matlab5.cc

I'd like to thank to the makers of Gamma

  S.A. Smith, T.O. Levante, B.H. Meier and R.R. Ernst
  Computer Simulations in Magnetic Resonance:
  An Object-Oriented Programming Approach
  J. Magn. Reson., 106a, 75-105, (1994S, Series A)

http://gamma.magnet.fsu.edu/

for much of this setup...
 *
 *The code for a matlab 5 file format...
 * for writing a single complex array
 *
 * PLEASE NOTE:: for some crazy reason...matlab will read the files
 * outputted by this class, but will NOT let the matlab user access them
 * or even read them...they show up in the 'whos' command, but are unknown
 * to the main frount end...an oddity i have not yet figured out
 *
 */

#ifndef _Matlab5_cc_
#define _Matlab5_cc_ 1

#include "utils/matlab5.h"
#include "utils/endians.h"
#include "utils/utils.h"
#include "container/complex.h"

#include <string>

#ifndef ON_WINDOWS
#include "blochconfig.h"
#include <sys/utsname.h>			// platform information
#endif

#if HAVE_UNISTD_H
	#include <unistd.h>
#endif

#include <time.h>

BEGIN_BL_NAMESPACE


using namespace BL_endians;

// Matlab 5 element types
const int miINT8=1;
const int miUINT8=2;
const int miINT16=3;
const int miUINT16=4;
const int miINT32=5;
const int miUINT32=6;
const int miSINGLE=7;
const int miDOUBLE=9;
const int miINT64=12;
const int miUINT64=13;
const int miMATRIX=14;

const int miCELL=1;
const int miSTRUCT=2;
const int miOBJ=3;
const int miCHARARR=4;
const int miSPARSEARR=5;
const int miDOUBLEARR=6;
const int miSINGLEARR=7;
const int miINT8ARR=8;
const int miUINT8ARR=9;
const int miINT16ARR=10;
const int miUINT16ARR=11;
const int miINT32ARR=12;
const int miUINT32ARR=13;

Matlab5Header::Matlab5Header()
{	SetHeader(); SetEndian();	}

Matlab5Header::Matlab5Header(const Matlab5Header &in)
{
	for(int i=0; i<124; i++)	txt[i] = in.txt[i];
	version = in.version;
	mm = in.mm;
	ii = in.ii;
	BigEndian_ = in.BigEndian_;
}

// Matlba 5 Header info
bool Matlab5Header::SetHeader(){
	std::string h="MATLAB 5.0 MAT-file";

//getting the system name info
	h+=", Platform: ";
#ifdef ON_WINDOWS
  h += "Windows";
#else
  struct utsname name;
  uname(&name);
  h += name.sysname;
#endif

//the creation time
	h+= ", Created on: ";
	time_t now;
	time(&now);
	h+=ctime(&now);
	//h+=" hmmmm ";
	//now we need to chop off the extra '\n' if present
	if(h[h.length()-1]=='\n')		h=h.substr(0, h.length()-1);

//generation flag
	h+=", Generated by Blochlib";


//assign it to 'hdr'
	unsigned int i;
	for(i=0;i<h.length();i++)		txt[i]=h[i];

//fill up any empty slots in hdr
	for(i=h.length();i<124;i++)		txt[i]=' ';

//set the matlab version number
	version=0x0100;
	return true;
}


//read  the header
int Matlab5Header::read(std::ifstream &fp)
{
	for(int i=0; i<124; i++){
		if(!fp || fp.eof()){
			std::cerr<<std::endl<<" Error Matlab5Header::read() "<<std::endl;
			std::cerr<<" Bad input file..."<<std::endl;
			return 0;
		}
		fp.read(&(txt[i]), sizeof(char));
	}
	fp.read((char*)&version, sizeof(short));
	fp.read((char*)&mm, sizeof(char));
	fp.read((char*)&ii, sizeof(char));
	(mm=='M')?BigEndian_=1:BigEndian_=0;
	if(BL_endians::AreWeBigEndian() == BigEndian_) BL_endians::ByteSwap(version);
	return 1;
}


//write the header
int Matlab5Header::write(std::ofstream &fp){
	if(!fp){
		std::cerr<<std::endl<<" Error Matlab5Header::write() "<<std::endl;
		std::cerr<<" Bad output file..."<<std::endl;
		return 0;
	}

	for(int i=0;i<124;i++){
		fp.write(&(txt[i]), sizeof(char));
	}

	fp.write((char *)&version, sizeof(short));
	fp.write((char *)&mm, sizeof(char));
	fp.write((char *)&ii, sizeof(char));
	return 1;
}

/***********************************/
//		Matlab TAG **************

Matlab5Tag::Matlab5Tag(int bigend)
{
	for(int i=0;i<8;i++) chars[i]=' ';
	nbytes=0;
	dtype=0;
	iscompressed=false;
	bigendian=bigend;
}

Matlab5Tag::Matlab5Tag()
{
	for(int i=0;i<8;i++) chars[i]=' ';
	nbytes=0;
	dtype=0;
	iscompressed=false;
	bigendian=0;
}

Matlab5Tag::Matlab5Tag(int Type, int nbyts, int bigend, int cmpres)
{
	bigendian=bigend;
	BL_endians::longchars LC;
	LC.value = Type;
	chars[0] = LC.chars[0];
	chars[1] = LC.chars[1];
	chars[2] = LC.chars[2];
	chars[3] = LC.chars[3];
	LC.value = nbyts;
	chars[4] = LC.chars[0];
	chars[5] = LC.chars[1];
	chars[6] = LC.chars[2];
	chars[7] = LC.chars[3];
	dtype = Type;
	nbytes=nbyts;
	iscompressed=cmpres;
}


Matlab5Tag::Matlab5Tag(const Matlab5Tag &in)
{
	for(int i=0;i<8;i++) chars[i]=in.chars[i];
	nbytes=in.nbytes;
	dtype=in.dtype;
	iscompressed=in.iscompressed;
	bigendian=in.bigendian;
}


Matlab5Tag &Matlab5Tag::operator=(const Matlab5Tag &in)
{
	if(this==&in) return *this;
	for(int i=0;i<8;i++) chars[i]=in.chars[i];
	nbytes=in.nbytes;
	dtype=in.dtype;
	iscompressed=in.iscompressed;
	bigendian=in.bigendian;
	return *this;
}



std::string Matlab5Tag::DataType() const
{
	switch(dtype){
		case 0: return std::string("empty"); break;
		case 1: return std::string("8 bit, signed"); break;
		case 2: return std::string("8 bit, unsigned"); break;
		case 3: return std::string("16 bit, signed"); break;
		case 4: return std::string("16 bit, unsigned"); break;
		case 5: return std::string("32 bit, signed"); break;
		case 6: return std::string("32 bit, unsigned"); break;
		case 7: return std::string("IEEE 754 single format"); break;
		case 8: return std::string("Reserved"); break;
		case 9: return std::string("IEEE 754 double format"); break;
		case 10: return std::string("Reserved"); break;
		case 11: return std::string("Reserved"); break;
		case 12: return std::string("64 bit, signed"); break;
		case 13: return std::string("64 bit, unsigned"); break;
		case 14: return std::string("MATLAB array"); break;
	}
	return std::string("Unknown");
}

std::string Matlab5Tag::DataSymbol() const
{
	switch(dtype)
	{
		case 0: return std::string("none"); break;
		case 1: return std::string("miINT8"); break;
		case 2: return std::string("miUINT8"); break;
		case 3: return std::string("miINT16"); break;
		case 4: return std::string("miUINT16"); break;
		case 5: return std::string("miINT32"); break;
		case 6: return std::string("miUINT32"); break;
		case 7: return std::string("miSINGLE"); break;
		case 8: return std::string("--"); break;
		case 9: return std::string("miDOUBLE"); break;
		case 10: return std::string("--"); break;
		case 11: return std::string("--"); break;
		case 12: return std::string("miINT64"); break;
		case 13: return std::string("miUINT64"); break;
		case 14: return std::string("miMATRIX"); break;
	}
	return std::string("Unknown");
}

void Matlab5Tag::IsCompressed() //I thank Gamma for this little function..even thier comments are here
{
	shortchars IC;			// We check for 0 in two of the bytes
	if(bigendian)				// If data in was big endian, then the
	{					// 3rd & 4th bytes will have the data
		IC.chars[0] = chars[1];	// type leaving bytes 1&2 empty (0)
		IC.chars[1] = chars[0];	// the tag isn't compressed, if it
	}
	else					// If data in was little endian, then
	{					// the 1st & 2nd bytes will have the
		IC.chars[0] = chars[2];	// data type in them, leaving the 3rd &
		IC.chars[1] = chars[3];	// 4th bytes empty (0) if uncompressed
	}
	(IC.value)?iscompressed=1:iscompressed=0;
}


//write a matlab tag
int Matlab5Tag::write(std::ofstream &fp)
{
	if(!fp){
		std::cerr<<std::endl<<" Error Matlab5Tag::write() "<<std::endl;
		std::cerr<<" Bad output file..."<<std::endl;
		return 0;
	}

	if(!iscompressed){
		long LI = dtype;
		fp.write((char*)&LI, sizeof(long));
		LI = nbytes;
		fp.write((char*)&LI, sizeof(long));
	}else{
		short NB = nbytes;
		short DT = dtype;
		if(BL_endians::AreWeBigEndian()){
			fp.write((char*)&NB, sizeof(short));
			fp.write((char*)&DT, sizeof(short));
		}else{
			fp.write((char*)&DT, sizeof(short));
			fp.write((char*)&NB, sizeof(short));
		}
	}
	return 1;
}

//read a Tag
int Matlab5Tag::read(std::ifstream &fp)
{
	for(int i=0; i<8; i++){ 						// as the tag text field
		if(!fp || fp.eof()){
			std::cerr<<std::endl<<" Error Matlab5Tag::read() "<<std::endl;
			std::cerr<<" Bad input file..."<<std::endl;
			return 0;
		}
		fp.read(&(chars[i]), sizeof(char));
	}

	IsCompressed();
	int swap = 0;
	if(bigendian != BL_endians::AreWeBigEndian()) swap++;	//the file endian is different then the CPU endian...
	if(iscompressed){						//if the tag is compressed the data is in 4 bytes...not 8
		shortchars IC;
		IC.chars[0] = chars[0];
		IC.chars[1] = chars[1];
		if(swap) ByteSwap(IC.value);
		if(bigendian) nbytes = IC.value;
		else       dtype  = IC.value;
		IC.chars[0] = chars[2];
		IC.chars[1] = chars[3];
		if(swap) ByteSwap(IC.value);
		if(bigendian) dtype  = IC.value;
		else       nbytes = IC.value;
		//std::cout<<std::endl<<"NB--comp:" <<nbytes<<std::endl;
	}else{
		BL_endians::longchars LC;
		LC.chars[0] = chars[0];
		LC.chars[1] = chars[1];
		LC.chars[2] = chars[2];
		LC.chars[3] = chars[3];
		if(swap) BL_endians::ByteSwap(LC.value);
		dtype = LC.value;
		LC.chars[0] = chars[4];
		LC.chars[1] = chars[5];
		LC.chars[2] = chars[6];
		LC.chars[3] = chars[7];
		if(swap) BL_endians::ByteSwap(LC.value);
		nbytes = LC.value;
		//std::cout<<std::endl<<"NB--NOTcomp:" <<nbytes<<std::endl;

	}
	//std::cout<<"NB: "<<nbytes<<" type: "<<dtype<<" compress "<<iscompressed<<std::endl;
	return 1;
}


/******************** SUb Data **************************/

Matlab5SubData::Matlab5SubData(){	data=NULL;	}
Matlab5SubData::Matlab5SubData(int bigend): tag(bigend)
{
	data=NULL;
	bigendian=bigend;
}

Matlab5SubData::~Matlab5SubData(){	if(data) delete [] data;	}

int Matlab5SubData::read(std::ifstream &fp)
{
	tag.bigendian=bigendian;
	if(!tag.read(fp))
	{	return 0;	}

	if(data) delete [] data;
	data = NULL;
	int nb = tag.nbytes;
	if(!tag.iscompressed && nb)
	{
		data = new char[nb];
		for(int i=0; i<nb; i++)		fp.read(&(data[i]), sizeof(char));
		int left = nb%8;
		if(left)
		{
			left = 8 - left;
			char x;
			for(int k=0; k<left; k++)	fp.read(&x, sizeof(char)); //skip ahead
		}
	}else{		//data in tag is this data...
		data = new char[4];
		for(int i=0; i<4; i++)	data[i] = tag.chars[4+i];
	}
	return 1;
}

int Matlab5SubData::write(std::ofstream &out){	return tag.write(out);			}


/***************** ARRAY FLAGS ********************/
Matlab5ArrayFlag::Matlab5ArrayFlag() : Matlab5SubData()
{ bigendian=0; firstb=0; Class=0;	}

Matlab5ArrayFlag::Matlab5ArrayFlag(int bigend): Matlab5SubData(bigend)
{ bigendian=0; firstb=0; Class=0;	}


Matlab5ArrayFlag::Matlab5ArrayFlag(int cmplx, int Clas, int bigend, int global,int logical):
	Matlab5SubData(bigend)
{
	             firstb = 0;
	  if(cmplx)   firstb += 8;
	  if(global)  firstb += 4;
	  if(logical) firstb += 2;
	              Class = Clas;
	  data = new char[8];
	  data[2] = char(firstb);
	  data[3] = char(Class);
}

std::string Matlab5ArrayFlag::ClassType() const
{
	switch(Class)
	{
		case 0: return std::string("None"); break;
		case 1: return std::string("Cell Array"); break;
		case 2: return std::string("Structure"); break;
		case 3: return std::string("Object"); break;
		case 4: return std::string("Character Array"); break;
		case 5: return std::string("Sparse Array"); break;
		case 6: return std::string("Double Precision Array"); break;
		case 7: return std::string("Single Precision Array"); break;
		case 8: return std::string("8 Bit, Signed Integer"); break;
		case 9: return std::string("8 Bit, Unsigned Integer"); break;
		case 10: return std::string("16 Bit, Signed Integer"); break;
		case 11: return std::string("16 Bit, Unsigned Integer"); break;
		case 12: return std::string("32 Bit, Signed Integer"); break;
		case 13: return std::string("32 Bit, Unsigned Integer"); break;
	}
	return std::string("Unknown");
}



int Matlab5ArrayFlag::write(std::ofstream& fp)
{
	tag.write(fp);
	char Data[8];
	if(BL_endians::AreWeBigEndian())
	{
		Data[3] = char(Class);
		Data[2] = char(firstb);
	}else{
		Data[0] = char(Class);
		Data[1] = char(firstb);
	}
	fp.write((char*)&Data, 8*sizeof(char));
	return 1;
}

int Matlab5ArrayFlag::read(std::ifstream& fp)
{
	if(!Matlab5SubData::read(fp))
	{	return 0;	}

	if(bigendian){
		Class = int(data[3]);
		firstb    = int(data[2]);
	}else{
		firstb    = int(data[1]);
	//	std::cout<<"FIRST: "<<firstb<<std::endl;
		Class = int(data[0]);
	}
	return 1;
}

/************8 ARRAY NAME ***************/

Matlab5ArrayName::Matlab5ArrayName(): Matlab5SubData()
{	name="fid"; numchars=3;	}

Matlab5ArrayName::Matlab5ArrayName(int bigend): Matlab5SubData(bigend)
{	name="fid"; numchars=3;	}

Matlab5ArrayName::Matlab5ArrayName(const std::string &inn, int bigend):
	Matlab5SubData(bigend)
{
	name=inn;
	numchars=inn.size();
	tag = Matlab5Tag(miINT8,numchars,bigend, (numchars<5)?1:0);
}

int Matlab5ArrayName::size() const { //must align on an 8 byte boundary
	int nbts = tag.size();
	int nl = name.size();
	if(nl>4)
	{
		nbts += nl;
		int left = nl%8;
		if(left) nbts += 8-left;
	}
  	return nbts;
}

int Matlab5ArrayName::size(std::string inn) const { //must align on an 8 byte boundary
	Matlab5Tag me(miINT8,inn.size(),0, (inn.size()<5)?1:0);
	int nbts=me.size();
	int nl = inn.size();
	if(nl>4)
	{
		nbts += nl;
		int left = nl%8;
		if(left) nbts += 8-left;
	}
  	return nbts;
}


int Matlab5ArrayName::write(std::ofstream &fp)
{
	if(!tag.write(fp)) return 0;
	numchars=name.size();
	char c;
	for(int i=0; i<numchars; i++)	{
		c = name[i];
		fp.write(&c, sizeof(char));
	}
	int left = numchars%8;
	if(numchars <= 4) left = numchars%4;
	if(left){
		left = 8-left;
		if(numchars <= 4) left = left-4;
		c = ' ';
		for(int i=0; i<left; i++)  fp.write(&c, sizeof(char));
	}
	return 1;
}

int Matlab5ArrayName::read(std::ifstream &fp)
{
	if(!Matlab5SubData::read(fp)) return 0;

	numchars = tag.nbytes;
	name = "";
	if(tag.iscompressed){
		for(int i=0; i<numchars; i++)	name += tag.chars[i+4];
	}else{
		for(int i=0; i<numchars; i++) name += data[i];
	}
	return 1;
}

/********** ARRAY DIMS ***************/

Matlab5ArrayDims::Matlab5ArrayDims(): Matlab5SubData()
{	dims=NULL; ndims=0;	}

Matlab5ArrayDims::Matlab5ArrayDims(int bigend) :Matlab5SubData(bigend)
{	dims=NULL;	ndims=0;	}




Matlab5ArrayDims::~Matlab5ArrayDims() { if(dims) delete [] dims; }

int Matlab5ArrayDims::size() const{	return 4*sizeof(long);	}

int Matlab5ArrayDims::write(std::ofstream &fp)
{
	int err = tag.write(fp);
	long LI;
	for(int i=0; i<ndims; i++)
	{
		LI = dims[i];
		fp.write((char*)&LI, sizeof(long));
	}
	return err;
}

int Matlab5ArrayDims::read(std::ifstream &fp)
{
	int MaxDims=5;
	int MaxDim=524288;
	if(!Matlab5SubData::read(fp)) return 0;

	ndims = tag.nbytes/4;
	if(ndims < 2 || ndims>MaxDims)
	{
		std::cerr<<std::endl<<"Error: Matlab5ArrayDims(read)"<<std::endl;
		std::cerr<<" error in number of dimensions...(should be 2 to "<<MaxDims<<")"<<std::endl;
		std::cerr<<" your Num Dims are: "<<ndims<<std::endl;
		return (0);
	}
	if(dims) delete [] dims;
	dims = new int[ndims];
	BL_endians::longchars LC;
	int swap = 0;
	if(bigendian != BL_endians::AreWeBigEndian()) swap++;
	for(int i=0; i<ndims; i++)
	{
		LC.chars[0] = data[0+4*i];
		LC.chars[1] = data[1+4*i];
		LC.chars[2] = data[2+4*i];
		LC.chars[3] = data[3+4*i];
		if(swap) ByteSwap(LC.value);
		dims[i] = int(LC.value);
		if(dims[i]<1 || dims[i]>MaxDim)
		{
			std::cerr<<std::endl<<"Error: Matlab5ArrayDims(read)"<<std::endl;
			std::cerr<<" error in dimension size...(should be 1 to "<<MaxDim<<")"<<std::endl;
			std::cerr<<" You dim is: "<<dims[i]<<std::endl;

			return (0);
		}
	}
	return 1;
}


/*************************** Real Data Chuck ******************/
Matlab5RealData::Matlab5RealData(): Matlab5SubData() {}

Matlab5RealData::Matlab5RealData(int bigend): Matlab5SubData(bigend) {}

/*************************** Imag Data Chuck ******************/
Matlab5ImagData::Matlab5ImagData(): Matlab5SubData() {}

Matlab5ImagData::Matlab5ImagData(int bigend): Matlab5SubData(bigend) {}

/****************** Total Matrix Data ELement ******************/

Matlab5MatData::Matlab5MatData()
{
	bigendian=0;
}

Matlab5MatData::Matlab5MatData(int bigend)
{
	bigendian=bigend;
	arrayflag.bigendian=bigendian;
	arraydim.bigendian=bigendian;
	arrayname.bigendian=bigendian;
	tag.bigendian=bigendian;
}

void Matlab5MatData::skip(std::ifstream& fp)
{
	if(!fp) return;
	tag.read(fp);
	if(!tag.iscompressed) fp.seekg(tag.nbytes, std::ios::cur);
}


void Matlab5MatData::whos(std::ostream& ostr, std::ifstream& fp)
{
	if(!fp) return;
	int pos = fp.tellg();
	int err = tag.read(fp);
	err *= arrayflag.read(fp);
	err *= arraydim.read(fp);
	err *= arrayname.read(fp);
	if(!err) return;
	ostr << "\n" << std::string(2, ' ');
	std::string name = arrayname.name;
	int len = name.length();

	if(len > 17)	ostr << name.substr(0,14) << "...";
	else	ostr << name << std::string(17-len, ' ');
	int ND = arraydim.ndims;
	std::string dimstr ;
	ostr << "  ";

	err = tag.read(fp);
	if(!err) return;
	int NB = tag.nbytes;
	int dimc=1;
	for(int i=0; i<ND; i++)
	{
		dimstr += itost(arraydim.dims[i]);
		dimc*=arraydim.dims[i];
		if(i<ND-1) dimstr += std::string("x");
	}
	len = dimstr.length();
	ostr << dimstr << std::string(10-len, ' ');

	if(NB==dimc){	NB*=sizeof(double);	}
	if(arrayflag.IsComplex()) NB *= 2;
	std::string byt = itost(NB);
	len = byt.length();
	ostr <<  std::string(10-len, ' ')<<byt<<"  ";
	ostr << arrayflag.ClassType();
	if(arrayflag.IsComplex())	ostr << " (complex)";
	ostr.flush();
	fp.seekg(pos);
}

/* These are the functions which will return the number of bytes that are
   written upon output this sub-element in MATLAB ".mat" binary format, V5   */


Matlab5::Matlab5(std::string inname,  std::ios::openmode imode)
{
	SetFile(inname, imode);
}

bool Matlab5::ModeCheck(std::ios::openmode imode)
{
	if( (imode & std::ios::app) )
	{
		std::cerr<<std::endl<<"Error: Matlab5.ModeCheck(mode)"<<std::endl;
		std::cerr<<" ios mode must be 'out' or 'in'"<<std::endl;
		return false;
	}
	return true;
}

int Matlab5::FileSize(std::ofstream &inf)
{
	int curp=inf.tellp();
	inf.seekp(0,std::ios::end);
	int s= inf.tellp();
	inf.seekp(curp, std::ios::cur);
	return s;
}

int Matlab5::FileSize(std::ifstream &inf)
{
	int curp=inf.tellg();
	inf.seekg(0,std::ios::end);
	int s= inf.tellg();
	inf.seekg(curp, std::ios::cur);
	return s;
}

bool Matlab5::open(std::string inname,std::ios::openmode imode)
{	return SetFile(inname, imode);	}

bool Matlab5::SetFile(std::string inname, std::ios::openmode imode)
{
	if(imode & std::ios::out){
		if(inname==fname && ofp){ canwrt=true; return true;	} // file already open
	}else if(imode & std::ios::in){
		if(inname==fname && ifp){ canwrt=false; return true;	} // file already open
	}
	fname=inname;
	if(fname.find(".mat")!=fname.size()-4)
	{		fname+=".mat";		}

	iomode=imode;
	if(!ModeCheck(iomode)) {	canwrt=false; return false;	}
	if(iomode & std::ios::out){
		if(ofp.is_open()){ ofp.close();	}
		ofp.open(fname.c_str(), iomode);
		if(ofp.fail())
		{
			std::cerr<<std::endl<<"Error: Matlab5(std::string)"<<std::endl;
			std::cerr<<" Cannot open File for writing.."<<std::endl;
			ofp.close();
			canwrt=false;
			return false;
		}
		fsize=FileSize(ofp);
		canwrt=true;
		return true;
	}else if(iomode & std::ios::in){
		if(ifp.is_open()){ ifp.close();	}
		ifp.open(fname.c_str(), imode);
		if(ifp.fail())
		{
			std::cerr<<std::endl<<"Error: Matlab5(std::string)"<<std::endl;
			std::cerr<<" Cannot open File for reading.."<<std::endl;
			ifp.close();
			canwrt=false;
			return false;
		}
		fsize=FileSize(ifp);
		canwrt=true;
		return true;
	}
	return false;
}

void Matlab5::close()
{
	ifp.close();
	ofp.close();
	canwrt=false;
	fsize=0;
}


void Matlab5::whos(std::ostream& ostr)
{
	if(iomode & std::ios::out){
		std::cerr<<std::endl<<" Error: matralb5::whos()"<<std::endl;
		std::cerr<<" cannot 'whos' an ouput stream "<<std::endl;
		return;
	}
	if(!ifp) return;
	if(!fsize ) return;
	std::string margin = std::string(2, ' ');
	std::string spcr = std::string(2, ' ');
	std::string ul10 = std::string(10, '-');
	ostr << "\n" << margin
		<< "Name" << std::string(19-4, ' ')
		<< "Size" << std::string(10-4, ' ')
		<< std::string(10-5, ' ')<<"Bytes"
		<< "  Class";
	ostr << "\n" ;int pos =  ifp.tellg();
	ifp.seekg(0);
	int bytesleft;
	Matlab5Header hdr;
	hdr.read(ifp);
	Matlab5MatData subdat(hdr.BigEndian());
	bytesleft = fsize - ifp.tellg();
	while(ifp.is_open() && bytesleft>0)
	{
		subdat.whos(ostr,ifp);
		subdat.skip(ifp);
		bytesleft = fsize - ifp.tellg();
	}
	ifp.seekg(pos);			// Reset original file position
	ostr<<std::endl;
}



//this returns a general variable (Always in a 'highest' bit count for that container)
//you must 'cast' it down to the proper format
complex Matlab5::GetVar(const std::string &vname)
{
	if(!ifp || !fsize)
	{
		std::cerr<<"Warning:: Matlab5::GetVar(name)"<<std::endl;
		std::cerr<<" Bad file input (either no file, or empty file) "<<std::endl;
		std::cerr<<" returning 0..."<<std::endl;
		return complex(0.,0.);
	}
	int bytesleft;
	ifp.seekg(0);
	Matlab5Header hdr;
	hdr.read(ifp);
	Matlab5MatData subdat(hdr.BigEndian());
	bytesleft = fsize - ifp.tellg();
	matrix mx;
	while(ifp.is_open() && bytesleft>0)
	{
		subdat.read(ifp,mx);
		if(subdat.arrayname.name==vname)
		{
			if(mx.rows()>1 || mx.cols()>1)
			{
				std::cerr<<"Warning:: Matlab5::GetVar(name)"<<std::endl;
				std::cerr<<" variable '"<<vname<<"' is bigger then a 'scalar'"<<std::endl;
				std::cerr<<" returning only the first entry..."<<std::endl;
			}
			if(mx.rows()==0 || mx.cols()==0)
			{
				std::cerr<<"Warning:: Matlab5::GetVar(name)"<<std::endl;
				std::cerr<<" variable '"<<vname<<"' has no value "<<std::endl;
				std::cerr<<" returning 0..."<<std::endl;
				return complex(0.,0.);
			}
			return mx(0,0);
		}
		subdat.skip(ifp);
		bytesleft = fsize - ifp.tellg();
	}
	std::cerr<<"Warning:: Matlab5::GetVar(name)"<<std::endl;
	std::cerr<<" variable '"<<vname<<"' is Not in this file... "<<std::endl;
	std::cerr<<" returning 0..."<<std::endl;
	return complex(0.,0.);
}

matrix Matlab5::GetMatrix(const std::string  &vname)
{
	if(!ifp || !fsize)
	{
		std::cerr<<"Warning:: Matlab5::GetMatrix(name)"<<std::endl;
		std::cerr<<" Bad file input (either no file, or empty file) "<<std::endl;
		std::cerr<<" returning Null Matrix..."<<std::endl;
		return matrix(0,0);
	}
	int bytesleft = fsize;
	ifp.seekg(0);
	Matlab5Header hdr;
	hdr.read(ifp);
	Matlab5MatData subdat(hdr.BigEndian());
	bytesleft = fsize - ifp.tellg();
	matrix mx;
	while(ifp.is_open() && bytesleft>0)
	{
		subdat.read(ifp,mx);
		if(subdat.arrayname.name==vname)
		{
			if(subdat.arraydim.ndims>2)
			{
				std::cerr<<"Warning:: Matlab5::GetMatrix(name)"<<std::endl;
				std::cerr<<" variable '"<<vname<<"' is bigger then a 2x2 matrix"<<std::endl;
				std::cerr<<" returning a null matrix..."<<std::endl;
				return matrix(1,1,0);
			}

			if(mx.rows()==0 || mx.cols()==0)
			{
				std::cerr<<"Warning:: Matlab5::GetMatrix(name)"<<std::endl;
				std::cerr<<" matrix '"<<vname<<"' has no value "<<std::endl;
				std::cerr<<" returning 0..."<<std::endl;
				return matrix(1,1,0);
			}
			return mx;
		}
		//subdat.skip(fp);
		//std::cout<<"MOO: "<<fp.tellp()<<" "<<subdat.arrayname.name<<std::endl;
		bytesleft = fsize - ifp.tellg();
	}
	std::cerr<<"Warning:: Matlab5::GetMatrix(name)"<<std::endl;
	std::cerr<<" matrix '"<<vname<<"' is Not in this file... "<<std::endl;
	std::cerr<<" returning 0..."<<std::endl;
	return matrix(1,1,0);
}

Vector<complex> Matlab5::GetVector(const std::string &vname)
{
	matrix mx=GetMatrix(vname);
	//std::cout<<"MOMO: "<<mx<<std::endl<<std::endl<<std::endl;
	if(mx.rows()==0 || mx.cols()==0)
	{
		std::cerr<<"Warning:: Matlab5::GetVector(name)"<<std::endl;
		std::cerr<<" Vector '"<<vname<<"' has no value "<<std::endl;
		std::cerr<<" returning 0..."<<std::endl;
		return Vector<complex>(0);
	}

	if(mx.rows()>1 && mx.cols()>1)
	{
		std::cerr<<"Warning:: Matlab5::GetVector(name)"<<std::endl;
		std::cerr<<" variable '"<<vname<<"' is a Matrix "<<std::endl;
		std::cerr<<" returning the first column..."<<std::endl;
		return mx.col(0);
	}

	int maxs=(mx.rows()>mx.cols())?mx.rows():mx.cols();
	if(mx.rows()==maxs){	return mx.col(0);	}
	else{	return mx.row(0);	}
	return mx.col(0);
}

std::string Matlab5::GetString(const std::string &vname)
{
	if(!ifp || !fsize)
	{
		std::cerr<<"Warning:: Matlab5::Getstd::string(name)"<<std::endl;
		std::cerr<<" Bad file input (either no file, or empty file) "<<std::endl;
		std::cerr<<" returning Null std::string..."<<std::endl;
		return std::string();
	}
	int bytesleft = fsize;
	ifp.seekg(0);
	Matlab5Header hdr;
	hdr.read(ifp);
	Matlab5MatData subdat(hdr.BigEndian());
	bytesleft = fsize - ifp.tellg();
	matrix mx;
	while(ifp.is_open() && bytesleft>0)
	{
		subdat.read(ifp,mx);
		if(subdat.arrayname.name==vname)
		{
			if(subdat.arraydim.ndims>2)
			{
				std::cerr<<"Warning:: Matlab5::Getstd::string(name)"<<std::endl;
				std::cerr<<" variable '"<<vname<<"' has too many dimensions for a std::string"<<std::endl;
				std::cerr<<" returning a null std::string..."<<std::endl;
				return std::string(0,' ');
			}
			if(mx.rows()==1 && mx.cols()==1)
			{
				std::cerr<<"Warning:: Matlab5::Getstd::string(name)"<<std::endl;
				std::cerr<<" variable '"<<vname<<"' is a 'scalar'"<<std::endl;
				std::cerr<<" returning only the first a 1 elemement vector..."<<std::endl;
			}
			if(mx.rows()==0 || mx.cols()==0)
			{
				std::cerr<<"Warning:: Matlab5::Getstd::string(name)"<<std::endl;
				std::cerr<<" matrix '"<<vname<<"' has no value "<<std::endl;
				std::cerr<<" returning 0..."<<std::endl;
				return std::string(0,' ');
			}
			int mdim=(mx.rows(), mx.cols())?mx.rows():mx.cols();
			std::string out(mdim, ' ');
			doublechars DC;
			if(mdim==mx.rows()){
				for(int i=0;i<mx.rows();++i){
					DC.value=Re(mx(0,i));
					out[i]=DC.chars[0];;
				}
			}else{
				for(int i=0;i<mx.cols();++i){
					DC.value=Re(mx(i,0));
					out[i]=DC.chars[0];;
				}
			}
			return out;
		}
		subdat.skip(ifp);
		bytesleft = fsize - ifp.tellg();
	}
	std::cerr<<"Warning:: Matlab5::Getstd::string(name)"<<std::endl;
	std::cerr<<" std::string '"<<vname<<"' is Not in this file... "<<std::endl;
	std::cerr<<" Null std::string..."<<std::endl;
	return std::string();
}


void Matlab5::get(const std::string &name, complex &in)
{
	in=GetVar(name);
}

void Matlab5::get(const std::string &name, std::string &in)
{
	in=GetString(name);
}

void Matlab5::get(const std::string &name, Vector<complex> &in)
{
	in=GetVector(name);
}

void Matlab5::initwrite(std::ofstream &out)
{
	if(!out) return;
	if(fsize) return;
	if(fsize==0){
		out.seekp(0);
		Matlab5Header hdr;
		hdr.SetEndian();
		hdr.write(out);
		fsize=hdr.size();
	}
}

void Matlab5::put(std::string name,const std::string &mx)
{
	if(canwrt){
		initwrite(ofp);
		_matrix<char, FullMatrix> mxo(mx.length(),0);
		for(unsigned int i=0;i<mx.length();i++){	mxo(i,0)=mx[i];	}
		Matlab5MatData mdat(mxo,name, BL_endians::AreWeBigEndian());
		if(!mdat.write(ofp, mxo,name))
		{
			std::cerr<<"Warning:: Matlab5::put(std::string)"<<std::endl;
			std::cerr<<" Error in writing '"<<name<<"' to file....."<<std::endl;
		}
	}else{
		std::cerr<<"Warning:: Matlab5::put(sting)"<<std::endl;
		std::cerr<<" file Cannot be written to (check 'ios' flags an permissions)"<<std::endl;
	}
}

void Matlab5::put( std::string name,const char *mx)
{	put(std::string(mx), name);	}


END_BL_NAMESPACE



#endif

