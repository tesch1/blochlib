/* edgedetect.h ********/


 /*
 * Copyright (c)2000-2001 Bo Blanton::UC Berkeley Dept of Chemistry
 * author:: Bo Blanton
 * contact:: magneto@dirac.cchem.berkeley.edu
 * last modified:: 08-21-01
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

 /*
 	edgedetect.h-->a simple class used for diffusion processes
 	given an XYZshape it will create four lists for each element
 	in the grid...it will determin if the grid point is an edge
 	along each direction

 	it simply loops through the grid, added a 'dr' to the current point
 	uses the 'shape function' to test if it is within the grid and assignes a
 	bool to the list (true false) if in the shape or not...

 	there are 2 methods of calculation for the edges

 	either it takes a XYZshape<ShapeFunc> and calculates it automatically

 	OR it can take the combo XYZshape generated by the '||' and '&&' process
 	to calculate the shape..

 */


 #ifndef _edgedetect_h_
 #define _edgedetect_h_


 #include "container/grids/xyzshape.h"
 #include "container/grids/coords.h"
#include "mpi/mpi_controller.h"

BEGIN_BL_NAMESPACE


//little strucutures to pass data around easily
template<int Dim>
struct CornerPos{
	coord<int, Dim> idx;
	coord<int, Dim> dir;
	CornerPos(): idx(-1), dir(0){};
};

//little strucutures to pass data around easily
template<int Dim>
struct EdgePos{
	coord<int, Dim> idx;
	coord<int, Dim> dir;
	EdgePos(): idx(-1), dir(0){};
};

 //Shape_t should be an "XYZshape<blaa>" class
 // ShapeFunc_t should be the "XYZrect, XYZplaneXY, etc"
 //  OR the combo style "XYZrect||XYZplaneXY"



 //pre dec for the iterator
template<class Shape_t>
class EdgeIterator;

 //pre dec for the iterator
template<class Shape_t>
class EdgeShapeIterator;


//here is the simple edge data strucutre (which is vectorized in the class below...)
template<int N=3>
class EdgeData
{
	public:
		coord<bool, 2*N> edge;

		EdgeData():
			edge(false)
		{}

		EdgeData(bool in):
			edge(in)
		{}

		EdgeData(int in):
			edge(in)
		{}

		EdgeData(coord<bool, 2*N> &in):
			edge(in)
		{}

		EdgeData(const EdgeData &cp):
			edge(cp.edge)
		{}

		EdgeData &operator=(const EdgeData &rhs)
		{
			if(&rhs==this) return *this;
			edge=rhs.edge;
			return *this;
		}

		EdgeData &operator=(const coord<bool,N> &rhs)
		{
			edge=rhs;
			return *this;
		}

	//MPI sender
		int put(MPIcontroller &sender, int to, int tag=20)
		{		return	sender.put(edge, to,tag);	}
	//MPI sender
		int send(MPIcontroller &sender, int to, int tag=20)
		{		return	sender.send(edge, to,tag);	}

	//MPI getter
		int get(MPIcontroller &sender, int from, int tag=20)
		{		return	sender.get(edge, from,tag);	}

		inline bool x(int dir){	return (dir==-1)?edge(0):edge(1);	}
		inline bool y(int dir){	return (dir==-1)?edge(2):edge(3);	}
		inline bool z(int dir){	return (dir==-1)?edge(4):edge(5);	}


		bool IsFace(){	for(int i=0;i<2*N;++i){ if(edge[i])	return true;	}; return false; }
		bool IsFace(int dim){	return edge[dim*2+1] || edge[dim*2];	}
		bool IsFace(int dir, int dim)
		{
			switch(dir)
			{
				case 0:	return edge[dim*2+1] || edge[dim*2];
				case 1: return edge[dim*2+1];
				case -1: return edge[dim*2];
				default:	return false;
			}
		}

		bool IsEdge(){
			int ct1=0;
			for(int i=0;i<2*N;++i){
				edge[i]?(++ct1):0;
				if(ct1>N-2) return true;
			}
			return false;
		}

		bool IsEdge(int dim){
			bool tm=IsFace(dim);
			for(int j=0;j<N;++j){
				if(dim!=j)
					if( (tm && IsFace(j)))	return true;
			}
			return false;
		}

		bool IsEdge(int dir, int dim){
			//bool tm;
			//tm=IsFace(dir, dim);
			return IsFace(dir, dim) && IsEdge();
			/*for(int j=0;j<2*N;j+=2){
				if(dim*2!=j || dim*2!=j+1)
					if(tm && IsFace(dir,j) || tm && IsFace(dir,j+1))	return true;
			}
			return false;*/
		}

/*		bool IsEdge(int dim, int dim2){
			if(dim==dim2) return false;
			return (edge[dim*2+1] || edge[dim*2]) && (edge[dim2*2+1] || edge[dim2*2]);
		}
*/
		bool IsEdge(int dir, int dim, int dim2)
		{
			if(dim==dim2) return false;
			switch(dir)
			{
				case 0: return IsEdge(dim, dim2);
				case 1: return edge[dim*2+1] && edge[dim2*2+1];
				case -1: return edge[dim*2] && edge[dim2*2];
				default: return false;
			}
		}

		EdgePos<N-1> EdgeIdx(){
			EdgePos<N-1> out;

			int ct=0, got=0;;
			for(int i=0;i<N;++i)
			{
				got=0;
				if(ct==N-1) break;
				if(!edge[i*2] && edge[i*2+1]){ got++; out.idx[ct]=i; out.dir[ct]=-1;} //direction is oposite to the edge direction
				if(!edge[i*2+1] && edge[i*2]){ got++; out.idx[ct]=i; out.dir[ct]=1;}
				if(got) ct++;
			}
			if(ct==(N-1)) return out;
			return EdgePos<N-1>();
		}

		bool IsCorner()
		{
			int ct1=0;
			for(int i=0;i<2*N;++i)
			{
				if(edge[i]) ct1++;
			}
			if(ct1>(N-1)) return true;
			return false;
		}

		bool IsCorner(int dir)
		{
			bool tm=true;
			switch(dir){
				case 1:
					for(int i=0;i<2*N;i+=2)
					{
						tm=tm && edge[i];
					}
					return tm;
				case -1:
					for(int i=0;i<2*N;i+=2)
					{
						tm=tm && edge[i+1];
					}
					return tm;
				default:
					return false;
			}
		}

		CornerPos<N> CornerIdx()
		{
			CornerPos<N> out;
			int ct=0, got=0;
			for(int i=0;i<N;++i)
			{
				got=0;
				if(!edge[2*i] && edge[2*i+1]){ got++; out.idx[ct]=i; out.dir[ct]=-1; }
				if(!edge[2*i+1] && edge[2*i]){ got++ ;out.idx[ct]=i; out.dir[ct]=1; }
				if(got) ct++;
			}
			if(ct==N) return out;
			return CornerPos<N>();
		}



		operator bool(){	return IsEdge();	}

		//this function one should use if determining edges OUTside this class...
		// it determins if the point is an edge or not...but not for the entire grid
		template<class Shape_t, class ShapeFunc_t>
		void CalcEdgesSingle(Shape_t &rhs, ShapeFunc_t tester, coord<> &pt, coord<> &dr)
		{
			if(tester.ShapeFunc(pt.x(), pt.y(), pt.z())){
				edge=false;
				if(!tester.ShapeFunc(pt.x()+dr.x(), pt.y(), pt.z())) edge(1)=true;
				if(!tester.ShapeFunc(pt.x()-dr.x(), pt.y(), pt.z())) edge(0)=true;

				if(!tester.ShapeFunc(pt.x(), pt.y()+dr.y(), pt.z())) edge(3)=true;
				if(!tester.ShapeFunc(pt.x(), pt.y()-dr.y(), pt.z())) edge(2)=true;

				if(!tester.ShapeFunc(pt.x(), pt.y(), pt.z()+dr.z())) edge(5)=true;
				if(!tester.ShapeFunc(pt.x(), pt.y(), pt.z()-dr.z())) edge(4)=true;
			}else{
				edge=true;
			}

		}


		void print(std::ostream &oo)
		{
			if(!IsEdge()){
				oo<<"Point is not an edge..";
				for(int i=0;i<N;++i)
				{
					if(IsFace(i)){
						oo<<"\n  Face along direction: "<<i;
					}
				}
				return;
			}
			for(int i=0;i<N;++i)
			{
				if(IsEdge(i)){
					oo<<"Edge along direction: "<<i<<std::endl;
				}
			}
		}
};

template<int N>
std::ostream &operator<<(std::ostream &oo, EdgeData<N> &out)
{
	out.print(oo);
	return oo;
}

template<class Shape_t>
class Edge
{


	private:
		Vector<EdgeData<3> > edges_; //directional edges
		Vector<int> index_;	//the 'iterator' index of the edge point...
		Shape_t *shape_;	//ptr to shape...

	public:

		const void EmptyErr()
		{
			std::cerr<<std::endl<<" Warning: Edge<Shape_t> "<<std::endl;
			std::cerr<<" Shape is EMPTY "<<std::endl;
		}

		friend class EdgeIterator<Shape_t>;
		friend class EdgeShapeIterator<Shape_t>;

		typedef EdgeIterator<Shape_t> iterator;
		typedef typename Shape_t::iterator Shapeiterator;
		typedef EdgeShapeIterator<Shape_t> TotalIterator;

		Edge():
			edges_(0),
			index_(0),
			shape_(0)
		{}

		template<class ShapeFunc_t>
		Edge(Shape_t &in, ShapeFunc_t tester):
			edges_(0),
			index_(0),
			shape_(&in)

		{
			CalcEdges(in, tester);
		}

		template<class ShapeFunc_t>
		Edge(Shape_t *in, ShapeFunc_t tester):
			edges_(0),
			index_(0),
			shape_(in)

		{
			CalcEdges(*in, tester);
		}

		~Edge(){	shape_=NULL;	}

		Edge &operator=(const Edge &rhs)
		{
			if(this==&rhs) return *this;
			edges_=rhs.edges_;
			index_=rhs.index_;
			shape_=rhs.shape_;
			return *this;
		}

		template<class ShapeFunc_t>
		void calculate(Shape_t &rhs, ShapeFunc_t tester){	CalcEdges(rhs, tester);	}

		template<class ShapeFunc_t>
		void CalcEdges(Shape_t &rhs, ShapeFunc_t tester)
		{
			typename Shape_t::iterator myit(rhs);
			static coord<bool,6> tmp(false);
			if(rhs.empty()){ EmptyErr();	 return;	}
			edges_.resize(rhs.size(), false);
			index_.resize(rhs.size());
			int i=0;
			int j=0;
			bool got=false;
			while(myit)
			{
				got=false;
				tmp=false;
				if(tester.ShapeFunc(myit.x(), myit.y(), myit.z())){
					if(!tester.ShapeFunc(myit.x()+myit.dx(), myit.y(), myit.z())){
						tmp(1)=true; tmp(0)=false;got=true;
					}else if(!tester.ShapeFunc(myit.x()-myit.dx(), myit.y(), myit.z())){
						tmp(0)=true; tmp(1)=false;got=true;
					}else{
						tmp(1)=false; tmp(0)=false;
					}

					if(!tester.ShapeFunc(myit.x(), myit.y()+myit.dy(), myit.z())){
						tmp(3)=true; tmp(2)=false;got=true;
					}else if(!tester.ShapeFunc(myit.x(), myit.y()-myit.dy(), myit.z())){
						tmp(2)=true; tmp(3)=false; got=true;
					}else{
						tmp(2)=false; tmp(3)=false;
					}

					if( !tester.ShapeFunc(myit.x(), myit.y(), myit.z()+myit.dz())){
						tmp(5)=true; tmp(4)=false; got=true;
					}else if(!tester.ShapeFunc(myit.x(), myit.y(), myit.z()-myit.dz())){
						tmp(4)=true; tmp(5)=false;  got=true;
					}else{
						tmp(5)=false; tmp(4)=false;
					}
				}
				edges_(i).edge=tmp;
				if(got){ index_(j)=myit.curpos();	j++;	}
				++i;
				++myit;
			}
			if(j==0){ EmptyErr(); }
			index_.resizeAndPreserve(j);
		}


		//this function one should use if determining edges OUTside this class...
		// it determins if the point is an edge or not...but not for the entire grid
		template< class ShapeFunc_t>
		coord<bool, 6> CalcEdgesSingle(Shape_t &rhs, ShapeFunc_t tester, coord<> &pt, coord<> &dr)
		{
			static coord<bool, 6> tmp(false);
			if(tester.ShapeFunc(pt.x(), pt.y(), pt.z())){
				if(!tester.ShapeFunc(pt.x()+dr.x(), pt.y(), pt.z())) tmp(1)=true;
				if(!tester.ShapeFunc(pt.x()-dr.x(), pt.y(), pt.z())) tmp(0)=true;

				if(!tester.ShapeFunc(pt.x(), pt.y()+dr.y(), pt.z())) tmp(3)=true;
				if(!tester.ShapeFunc(pt.x(), pt.y()-dr.y(), pt.z())) tmp(2)=true;

				if( !tester.ShapeFunc(pt.x(), pt.y(), pt.z()+dr.z()))	tmp(5)=true;
				if(!tester.ShapeFunc(pt.x(), pt.y(), pt.z()-dr.z()))	tmp(4)=true;
			}
			return tmp;
		}



		inline coord<> &Point(int i){	return shape_->Point(i);	}

		inline bool empty(){	return index_.size()<=0;	}

		inline bool &xedge(int i,int dir){	return edges_(i).x(dir);	}
		inline bool &yedge(int i,int dir){	return edges_(i).y(dir);	}
		inline bool &zedge(int i,int dir){	return edges_(i).z(dir);	}
		inline coord<bool,6> &edge(int i){	return edges_(i).edge;	}

		inline bool xedge(int i,int dir)const{	return edges_(i).x(dir);	}
		inline bool yedge(int i,int dir)const{	return edges_(i).y(dir);	}
		inline bool zedge(int i, int dir)const{	return edges_(i).z(dir);	}
		inline coord<bool,6> edge(int i)const{	return edges_(i).edge;	}

		template<class ShapeFunc_t>
		inline void CalcEdge(Shape_t &rhs, ShapeFunc_t tester){	CalcEdges(rhs, tester);	}

		void print(std::ostream &oo)
		{
			iterator myit(*this);
			while(myit)
			{
				oo<<myit.Point()<<endl;
				++myit;
			}
		}

		void print(){	print(std::cout);	}
};

template<class Shape_t>
std::ostream &operator<<(std::ostream &oo, Edge<Shape_t> &out)
{
	out.print(oo);
	return oo;
}

//the iterator for the edges...
// follows the 'shape_t' itterator, with the added function of 'isedge'

template<class Shape_t>
class EdgeIterator
{
	private:
		Edge<Shape_t> *ed_;
		EdgeData<3> *cured_;
		coord<> *curpt_;
		bool notended_;
		int pos;

	public:
		typedef typename Shape_t::iterator Shapeiterator;

		EdgeIterator():
			ed_(0),
			cured_(0),
			curpt_(0),
			notended_(true),
			pos(0)
		{}

		EdgeIterator(Edge<Shape_t> &in):
			ed_(&in),
			notended_(true),
			pos(0)
		{
			if(!ed_->empty()){
				cured_=(&in.edges_(0));
				curpt_=(&in.Point(ed_->index_(0)));
			}else{
				cured_=0;
				curpt_=0;
			}
		}

		~EdgeIterator()
		{
			ed_=NULL;
			cured_=NULL;
			curpt_=NULL;
		}

		inline bool isedge()
		{
			return true;
		}

		void operator++()
		{
			if(pos<ed_->index_.size()-1 && !ed_->empty() & notended_){
				pos++;
				curpt_=&(ed_->Point(ed_->index_(pos)));
				cured_=&(ed_->edges_(ed_->index_(pos)));
			}
			else{	notended_=false; return;	}


		}


		inline coord<> &Point(){	return *curpt_;	}

		inline int curpos(){	return pos;	}

		inline operator bool(){ return notended_;	}

		void operator++(int){	operator++();	}

		inline bool xedge(){	return cured_->x();	}
		inline bool yedge(){	return cured_->y();	}
		inline bool zedge(){	return cured_->z();	}
		inline coord<bool, 3> edge(){	return cured_->edge;	}

};

//the iterator for the edges...
// follows the 'shape_t' itterator, with the added function of 'isedge'

template<class Shape_t>
class EdgeShapeIterator : public Shape_t::iterator
{
	private:
		Edge<Shape_t> *ed_;
		coord<bool,3> *cured_;

	public:
		typedef typename Shape_t::iterator Shapeiterator;

		EdgeShapeIterator():
			Shapeiterator(),
			ed_(0),
			cured_(0)
		{}

		EdgeShapeIterator(Edge<Shape_t> &in):
			Shapeiterator(in.shape_),
			ed_(&in),
			cured_(&in.edges_(0))
		{
			if(!ed_->empty()){
				cured_=(&in.edges_(0));
			}else{
				cured_=0;
			}

		}

		~EdgeShapeIterator()
		{
			ed_=NULL;
			cured_=NULL;
		}

		inline bool isedge()
		{
			if(xedge() || yedge() || zedge() ) return true;
			return false;
		}

		void operator++()
		{
			Shapeiterator::operator++();
			cured_=&(ed_->edges_(curpos()));

		}


		void operator++(int){	operator++();	}

		inline bool xedge(){	return cured_->x();	}
		inline bool yedge(){	return cured_->y();	}
		inline bool zedge(){	return cured_->z();	}
		inline coord<bool, 3> edge(){	return *cured_;	}

};

END_BL_NAMESPACE


#endif



